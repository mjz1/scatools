#' Bin atac fragments
#'
#' Convenience wrapper to bin fragments of a given size and save them as `.mtx` files
#'
#' @inherit bin_frags
#'
#' @param ArrowFiles List or vector of ArrowFile paths
#' @param bin_name Name of the bins (e.g. `'10Mb'`, `'500Kb'`, `'chr_arm'`). If not provided is automatically detected based on binwidth.
#' @param overwrite Logical. Overwrite previously existing results (default = FALSE)
#' @param return_mat Logical. Return the binned depth matrix (default = FALSE)
#' @param ... Additional parameters passed to `bplapply`
#'
#' @return If `return_mat=TRUE`, returns a sparse binned depth matrix. Otherwise returns `NULL`
#'
#' @export
bin_atac_frags <- function(ArrowFiles, bins, outdir, bin_name = prettyMb(getmode(width(bins))), ncores = 1, bpparams = BiocParallel::MulticoreParam(workers = ncores, progressbar = TRUE), overwrite = FALSE, return_mat = FALSE, ...) {
  # TODO: optional outdir if we don't want to save

  stopifnot(class(bins) %in% "GRanges")

  # Compute fragments per bins and combine
  matlist <- lapply(X = seq_along(ArrowFiles), FUN = function(i) {
    sample_name <- names(ArrowFiles[i])
    ArrowFile <- ArrowFiles[i]
    sample_outdir <- file.path(outdir, bin_name, sample_name)

    # Only bin frags if not done already
    if (!file.exists(file.path(sample_outdir, "matrix.mtx.gz")) | overwrite) {
      message("Computing fragments for ", sample_name)
      tmp <- bin_frags(ArrowFile = ArrowFile, bins = bins, outdir = sample_outdir, ncores = ncores, ...)
      return(tmp)
    } else {
      message("Fragments files already found for ", sample_name)
    }
  })

  # Invisible return
  if (return_mat) {
    # or bind and then return
    res <- do.call("rbind", matlist)
    return(res)
  } else {
    return(invisible(NULL))
  }
}


#' Bin fragments from ArrowFile
#'
#' Parallel enabled depth counting of read fragments in given genomic bins from `ArchR` processed ArrowFiles
#'
#' @param ArrowFile ArrowFile
#' @param bins Bins GRanges object
#' @param outdir Optional: Directory to write the `.mtx`, `barcodes`, and `bins` files
#' @param ncores Number of cores to use
#' @param bpparams Options to `BPPARAM` to enable multithreading
#' @param ... Additional arguments passed to `bplapply`
#'
#' @return Binned depth sparse matrix
#' @export
bin_frags <- function(ArrowFile, bins, outdir = NULL, ncores = 1, bpparams = BiocParallel::MulticoreParam(workers = ncores, progressbar = TRUE), ...) {
  requireNamespace("BiocParallel")

  stopifnot(class(bins) %in% "GRanges")

  message("Counting fragments in ", length(bins), " bins using ", ncores, " cores")

  result <- do.call("rbind", BiocParallel::bplapply(
    X = levels(BSgenome::seqnames(bins)),
    FUN = bin_frags_chr,
    bins = bins,
    ArrowFile = ArrowFile,
    BPPARAM = bpparams
  ))

  if (!is.null(outdir)) {
    cat("Writing to", outdir, "\n")
    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)

    # Write output using dropletutils
    DropletUtils::write10xCounts(path = outdir, x = result, barcodes = colnames(result), gene.id = rownames(result), version = "3", overwrite = TRUE, gene.type = "Bin Counts")
  }

  return(result)
}


#' Bin scATAC fragments
#'
#' \code{bin_frags_chr} computes the fragments across bins in a single chromosome from an ArchR ArrowFile
#'
#' @param chr A single chromsome to compute depth information
#' @param bins A list of bins (can include all chromosomes)
#' @param ArrowFile Path to an ArrowFile generated by `ArchR`
#'
#' @return Sparse matrix of binned fragment counts
#' @export
#'
#' @examples
#' \dontrun{
#' dp_mat <- bin_frags_chr("chr1", get_chr_arm_bins("hg38"), ArrowFile)
#' }
bin_frags_chr <- function(chr, bins, ArrowFile) {
  if (!requireNamespace("ArchR", quietly = TRUE)) {
    stop("Package \"ArchR\" must be installed to use this function.")
  }

  stopifnot(length(chr) == 1)
  stopifnot(class(bins) %in% "GRanges")
  stopifnot(file.exists(ArrowFile))

  # Fix for parallel HDF5 access (if this function is passed to parallel loop)
  # We scope only to this function
  withr::local_envvar(c("HDF5_USE_FILE_LOCKING" = FALSE, "RHDF5_USE_FILE_LOCKING" = FALSE))

  # Export needed functions
  # .getFragsFromArrow <- utils::getFromNamespace(".getFragsFromArrow", "ArchR")
  # .availableCells <- utils::getFromNamespace(".availableCells", "ArchR")
  # h5closeAll <- utils::getFromNamespace("h5closeAll", "rhdf5")


  # Load ArchR package temporarily (if not loaded) to execute the following commands
  # This is required as ArchR has depends from rhdf5 and other packages that it does not properly reference using '::'
  # Side effect is that the ArchR namespace remains attached afterwards (ie all the packages it depends on)
  if (!"ArchR" %in% .packages()) {
    withr::local_package(package = "ArchR")
    ArchR::addArchRThreads(1)
  }

  # Export needed functions
  .getFragsFromArrow <- utils::getFromNamespace(".getFragsFromArrow", "ArchR")
  .availableCells <- utils::getFromNamespace(".availableCells", "ArchR")

  # Get cells
  cellNames <- .availableCells(ArrowFile)

  # Read in Fragments
  fragments <- .getFragsFromArrow(ArrowFile, chr = chr, out = "GRanges", cellNames = cellNames)


  # TODO: Remove fragments in blacklist regions?

  # Chromosome bins
  bins_chr <- bins[BSgenome::seqnames(bins) == chr]

  # Get overlapping indices
  # Note: Each fragment represents two transposition events
  # Therefore we count both the start and end site of each independently
  start_hits <- GenomicRanges::findOverlaps(
    subject = bins_chr,
    query = GRanges(
      seqnames = chr,
      IRanges::IRanges(
        start = GenomicRanges::start(fragments),
        end = GenomicRanges::start(fragments)
      )
    )
  )
  end_hits <- GenomicRanges::findOverlaps(
    subject = bins_chr,
    query = GenomicRanges::GRanges(
      seqnames = chr,
      IRanges::IRanges(
        start = GenomicRanges::end(fragments),
        end = GenomicRanges::end(fragments)
      )
    )
  )

  # Match Cells
  matchID <- S4Vectors::match(mcols(fragments)$RG, cellNames)

  # Create Sparse Matrix
  mat <- Matrix::sparseMatrix(
    i = c(to(start_hits), to(end_hits)),
    j = as.vector(c(matchID, matchID)),
    x = rep(1, 2 * length(fragments)),
    dims = c(length(bins_chr), length(cellNames))
  )

  # Name matrix
  colnames(mat) <- cellNames
  rownames(mat) <- paste(GenomicRanges::seqnames(bins_chr),
    GenomicRanges::start(bins_chr),
    GenomicRanges::end(bins_chr),
    sep = "_"
  )

  # Clean and return
  rm(fragments, matchID)
  gc()
  return(mat)
}


#' Get chromosome arm bins
#'
#' @param genome Genome version ('hg38', 'hg19')
#' @param calc_gc Logical: Whether or not to calculate GC content per bin
#' @param bs_genome BSgenome object. Must be passed if `calc_gc` is set to `TRUE`
#'
#' @return A GRanges object of chromosome arm bins
#' @export
#'
#' @examples
#' bins <- get_chr_arm_bins("hg38")
get_chr_arm_bins <- function(genome = "hg38", calc_gc = FALSE, bs_genome = NULL) {
  bins <- get_cytobands() %>%
    dplyr::group_by(CHROM, arm, genome) %>%
    dplyr::summarise(
      "start" = min(start),
      "end" = max(end)
    ) %>%
    dplyr::mutate("bin_id" = paste(CHROM, start, end, sep = "_")) %>%
    GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = T)
  bins$binwidth <- IRanges::width(bins)

  if (calc_gc) {
    if (is.null(bs_genome)) {
      stop("To calculate GC content you must pass a BSgenome object")
    }
    stopifnot(class(bs_genome) %in% "BSgenome")

    bins <- add_gc_freq(bins = bins, bs_genome = bs_genome)
  }
  bins <- sort(bins)

  return(bins)
}

#' Get tiled bins
#'
#' @param bs_genome A BSgenome object
#' @param tilewidth Bin size
#' @param select_chrs Vector of chromosomes to include
#'
#' @return A GRanges object of bins
#' @export
#'
#' @examples
#' \dontrun{
#' bins <- get_tiled_bins(BSgenome.Hsapiens.UCSC.hg38, tilewidth = 500000)
#' }
get_tiled_bins <- function(bs_genome, tilewidth = 500000, select_chrs = NULL) {
  stopifnot(class(bs_genome) %in% "BSgenome")

  if (is.null(select_chrs)) {
    select_chrs <- paste("chr", c(1:22, "X"), sep = "")
  }

  bins <- GenomicRanges::tileGenome(BSgenome::seqinfo(bs_genome)[select_chrs],
    tilewidth = tilewidth,
    cut.last.tile.in.chrom = TRUE
  )
  bins$binwidth <- IRanges::width(bins)

  bins$bin_id = paste(seqnames(bins), start(bins), end(bins), sep = "_")

  bins <- add_gc_freq(bs_genome, bins)
  bins <- sort(bins)
  return(bins)
}


#' Get genome cytobands
#'
#' @param genome Genome version (hg38 or hg19)
#'
#' @return Dataframe of genome cytobands
#' @export
#'
#' @examples
#' hg38_cyto <- get_cytobands("hg38")
get_cytobands <- function(genome = "hg38") {
  cyto_url <- paste0("http://hgdownload.cse.ucsc.edu/goldenpath/", genome, "/database/cytoBand.txt.gz")
  cyto <- readr::read_delim(file = "http://hgdownload.cse.ucsc.edu/goldenpath/hg38/database/cytoBand.txt.gz", col_names = c("CHROM", "start", "end", "cytoband", "unsure"), show_col_types = FALSE) %>%
    dplyr::filter(!is.na(cytoband)) %>%
    dplyr::mutate(dplyr::across(where(is.character), as.factor),
      "start" = start + 1,
      "arm" = factor(substr(cytoband, 0, 1)),
      "genome" = genome
    )
  return(cyto)
}


#' Add GC frequency
#'
#' @param bs_genome BSGenome object
#' @param bins GRanges bins object
#'
#' @return GRanges bin object with GC and N frequency per bin
#' @export
#'
add_gc_freq <- function(bs_genome, bins) {
  stopifnot(class(bs_genome) %in% "BSgenome")
  message("Computing GC content...")
  freqs <- BSgenome::alphabetFrequency(BSgenome::getSeq(bs_genome, bins))
  bins$gc <- (freqs[, "C"] + freqs[, "G"]) / rowSums(freqs)

  # Add N frequency
  bins$n_freq <- (freqs[, "N"]) / rowSums(freqs)

  return(bins)
}
