#' Bin fragments from ArrowFile
#'
#' Parallel enabled depth counting of read fragments in given genomic bins
#'
#' @param ArrowFile ArrowFile
#' @param bins Bins GRanges object
#' @param outfile Optional: Path to write output `.mtx` file
#' @param ncores Number of cores to use
#' @param BPPARAM Options to `BPPARAM` to enable multithreading
#' @param ... Additional arguments passed to `bplapply`
#'
#' @return Binned depth sparse matrix
#' @export
bin_frags <- function(ArrowFile, bins, outfile = NULL, ncores = 1, BPPARAM = BiocParallel::MulticoreParam(workers = ncores, progressbar = TRUE), ...) {
  requireNamespace("BiocParallel")

  stopifnot(class(bins) %in% "GRanges")

  message("Counting fragments in ", length(bins), " bins using ", ncores, " cores")

  result <- do.call("rbind", BiocParallel::bplapply(
    X = seqlevels(bins),
    FUN = bin_frags_chr,
    bins = bins,
    ArrowFile = ArrowFile,
    BPPARAM = BPPARAM
  ))

  if (!is.null(outfile)) {
    cat("Writing to ", paste0(outfile, ".gz"), "\n")
    Matrix::writeMM(obj = result, file = outfile)
    R.utils::gzip(outfile, overwrite = TRUE, remove = TRUE)

    # Save barcodes
    write.table(
      file = file.path(dirname(outfile), "barcodes.tsv"),
      x = colnames(result), quote = FALSE, row.names = FALSE
    )
    # Save bins
    write.table(
      file = file.path(dirname(outfile), "bins.tsv"),
      x = rownames(result), quote = FALSE, row.names = FALSE
    )
  }

  return(result)
}


#' Bin scATAC fragments
#'
#' \code{bin_frags_chr} computes the fragments across bins in a single chromosome from an ArchR ArrowFile
#'
#' @param chr A single chromsome to compute depth information
#' @param bins A list of bins (can include all chromosomes)
#' @param ArrowFile Path to an ArrowFile generated by `ArchR`
#'
#' @return Sparse matrix of binned fragment counts
#' @export
#'
#' @examples
#' \dontrun{
#' dp_mat <- bin_frags_chr("chr1", get_chr_arm_bins("hg38"), ArrowFile)
#' }
bin_frags_chr <- function(chr, bins, ArrowFile) {
  requireNamespace("ArchR", quietly = TRUE)

  stopifnot(length(chr) == 1)
  stopifnot(class(bins) %in% "GRanges")
  stopifnot(file.exists(ArrowFile))

  # Fix for parallel HDF5 access (if this function is passed to parallel loop)
  # We scope only to this function
  withr::local_envvar(c("HDF5_USE_FILE_LOCKING" = FALSE, "RHDF5_USE_FILE_LOCKING" = FALSE))
  Sys.getenv(c("HDF5_USE_FILE_LOCKING", "RHDF5_USE_FILE_LOCKING"))

  # Export needed functions
  .getFragsFromArrow <- utils::getFromNamespace(".getFragsFromArrow", "ArchR")
  .availableCells <- utils::getFromNamespace(".availableCells", "ArchR")

  cellNames <- .availableCells(ArrowFile)

  # Read in Fragments
  fragments <- .getFragsFromArrow(ArrowFile, chr = chr, out = "GRanges", cellNames = cellNames)

  # TODO: Remove fragments in blacklist regions?

  # Chromosome bins
  bins_chr <- bins[BSgenome::seqnames(bins) == chr]

  # Get overlapping indices
  # Note: Each fragment represents two transposition events
  # Therefore we count both the start and end site of each independently
  start_hits <- GenomicRanges::findOverlaps(
    subject = bins_chr,
    query = GRanges(
      seqnames = chr,
      IRanges::IRanges(
        start = start(fragments),
        end = start(fragments)
      )
    )
  )
  end_hits <- GenomicRanges::findOverlaps(
    subject = bins_chr,
    query = GenomicRanges::GRanges(
      seqnames = chr,
      IRanges::IRanges(
        start = end(fragments),
        end = end(fragments)
      )
    )
  )

  # Match Cells
  matchID <- S4Vectors::match(mcols(fragments)$RG, cellNames)

  # Create Sparse Matrix
  mat <- Matrix::sparseMatrix(
    i = c(to(start_hits), to(end_hits)),
    j = as.vector(c(matchID, matchID)),
    x = rep(1, 2 * length(fragments)),
    dims = c(length(bins_chr), length(cellNames))
  )

  # Name matrix
  colnames(mat) <- cellNames
  rownames(mat) <- paste(GenomicRanges::seqnames(bins_chr),
    GenomicRanges::start(bins_chr),
    GenomicRanges::end(bins_chr),
    sep = "_"
  )

  # Clean and return
  rm(fragments, matchID)
  gc()
  return(mat)
}


#' Get chromosome arm bins
#'
#' @param genome Genome version ('hg38', 'hg19')
#'
#' @return A GRanges object of chromosome arm bins
#' @export
#'
#' @examples
#' bins <- get_chr_arm_bins("hg38")
get_chr_arm_bins <- function(genome = "hg38") {
  bins <- get_cytobands() %>%
    dplyr::group_by(CHROM, arm, genome) %>%
    dplyr::summarise(
      start = min(start),
      end = max(end)
    ) %>%
    dplyr::mutate(bin_id = paste(CHROM, start, end, sep = "_")) %>%
    GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = T)
  return(bins)
}

#' Get tiled bins
#'
#' @param bs_genome A BSgenome object
#' @param tilewidth Bin size
#' @param select_chrs Vector of chromosomes to include
#'
#' @return A GRanges object of bins
#' @export
#'
#' @examples
#' \dontrun{
#' bins <- get_tiled_bins(BSgenome.Hsapiens.UCSC.hg38, tilewidth = 500000)
#' }
get_tiled_bins <- function(bs_genome, tilewidth = 500000, select_chrs = NULL) {
  stopifnot(class(bs_genome) %in% "BSgenome")

  if (is.null(select_chrs)) {
    select_chrs <- paste("chr", c(1:22, "X"), sep = "")
  }

  bins <- GenomicRanges::tileGenome(BSgenome::seqinfo(bs_genome)[select_chrs],
    tilewidth = tilewidth,
    cut.last.tile.in.chrom = TRUE
  )

  bins <- add_gc_freq(bs_genome, bins)
  return(bins)
}


#' Get genome cytobands
#'
#' @param genome Genome version (hg38 or hg19)
#'
#' @return Dataframe of genome cytobands
#' @export
#'
#' @examples
#' hg38_cyto <- get_cytobands("hg38")
get_cytobands <- function(genome = "hg38") {
  cyto_url <- paste0("http://hgdownload.cse.ucsc.edu/goldenpath/", genome, "/database/cytoBand.txt.gz")
  cyto <- vroom::vroom("http://hgdownload.cse.ucsc.edu/goldenpath/hg38/database/cytoBand.txt.gz",
    col_names = c("CHROM", "start", "end", "cytoband", "unsure")
  ) %>%
    dplyr::filter(!is.na(cytoband)) %>%
    dplyr::mutate(across(where(is.character), as.factor),
      start = start + 1,
      arm = factor(substr(cytoband, 0, 1)),
      genome = genome
    )
  return(cyto)
}


#' Add GC frequency
#'
#' @param bs_genome BSGenome object
#' @param bins GRanges bins object
#'
#' @return GC frequency per bin
#' @export
#'
add_gc_freq <- function(bs_genome, bins) {
  stopifnot(class(bs_genome) %in% "BSgenome")
  freqs <- BSgenome::alphabetFrequency(BSgenome::getSeq(bs_genome, bins))
  bins$gc <- (freqs[, "C"] + freqs[, "G"]) / rowSums(freqs)
  return(bins)
}
