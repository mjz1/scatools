
#' Get SNP bin idx
#'
#' @inheritParams bin_snp_data
#' @inheritParams get_tiled_bins
#' @param merge_cols Vector of columns from `bins` to append to the `snp` ranges.
#' @return `SingleCellExperiment` object with SNPs with bin idx for each snp
#' @export
#'
get_snp_bidx <- function(snp,
                         tilewidth = 1e7,
                         respect_chr_arms = FALSE,
                         select_chrs = NULL,
                         bs_genome = NULL,
                         bins = get_tiled_bins(
                           bs_genome = bs_genome,
                           tilewidth = tilewidth,
                           select_chrs = select_chrs,
                           respect_chr_arms = respect_chr_arms
                         ),
                         merge_cols = NULL) {

  # Then overlap with findoverlaps
  hits <- GenomicRanges::findOverlaps(bins, rowRanges(snp))


  # Add indexing
  mcols(rowRanges(snp))[S4Vectors::subjectHits(hits), 'bin_idx'] <- S4Vectors::queryHits(hits)

  # And other information
  if (!is.null(merge_cols)) {
    logger::log_info("Merging columns: [{paste(merge_cols, collapse = ', ')}] onto snp object")
    for (x in merge_cols) {
      if (!x %in% colnames(mcols(bins))) {
        logger::log_warn("merge_cols: {x} not found in bins object. Dropping from merge")
        merge_cols <- merge_cols[-which(merge_cols == x)]
      }
    }
    if (length(merge_cols) > 0) {
      mcols(rowRanges(snp))[, merge_cols] <- mcols(bins)[mcols(rowRanges(snp))$bin_idx, merge_cols]
    } else {
      logger::log_warn("No columns left to merge from bins onto snp data")
    }
  }


  return(snp)
}

#' Bin SNPs into genomic segments
#'
#' @inheritParams get_tiled_bins
#' @param snp SingleCellExperiment SNP object generated by [read_vartrix]
#' @param bins GRanges object with genome bins. Automatically generated by [get_tiled_bins] if not provided.
#'
#' @return SCE object with binned SNPs
#' @export
#'
bin_snp_data <- function(snp,
                         tilewidth = 1e7,
                         respect_chr_arms = FALSE,
                         select_chrs = NULL,
                         bs_genome = NULL,
                         bins = get_tiled_bins(
                           bs_genome = bs_genome,
                           tilewidth = tilewidth,
                           select_chrs = select_chrs,
                           respect_chr_arms = respect_chr_arms
                         )) {



  # Pull out snp granges
  snp_granges <- rowRanges(snp)

  # Then overlap with findoverlaps
  hits <- GenomicRanges::findOverlaps(bins, snp_granges)

  # Add the bin index for aggregation
  snp_granges$bin_idx <- S4Vectors::queryHits(hits)


  # For each cell we want to aggregate the SNP depths per cell correcting for phasing
  # First get indices of the 0|1 vs 1|0 gts
  test <- snp_sce[, 1]

  colSums(assay(test, "ref"))

  which(snp_granges$gt == "0|1")
  which(snp_granges$gt == "1|0")

  # get the bin_ids
  bin_ids <- as.data.frame(bins) %>%
    select(seqnames, start, end) %>%
    unite("bin_id") %>%
    pull()

  # Have to aggregate per cell and end up with a matrix same shape as the bins
  snp_bins <- snp_granges %>%
    as_tibble() %>%
    filter(GT != "1|1") %>%
    # Adjust the phasing
    mutate(AD_phased = ifelse(GT == "1|0", DP - AD, AD)) %>%
    group_by(cell, bin_idx, GT) %>%
    summarise(
      DP = sum(DP),
      AD = sum(AD),
      AD_phased = sum(AD_phased),
      n_snps = n()
    ) %>%
    mutate(BAF = AD / DP)


  snp_bins$bin_id <- bin_ids[snp_bins$bin_idx]

  snp_bins <- snp_bins %>%
    separate(col = bin_id, into = c("chr", "start", "end"), sep = "_", remove = F)

  return(snp_bins)
}
